# AI Development Directives for Kolect

## Project Overview
- **Type**: Vue 3 + Tauri mobile app for K-pop collection tracking
- **Frontend**: Vue 3.5 (Composition API), TypeScript, DaisyUI, Tailwind CSS
- **Backend**: Rust with Tauri, SQLite database
- **Build Tool**: Bun
- **I18n**: EN/FR localization via vue-i18n

## Core Principles

### 1. Type Safety
- **NEVER** use magic strings - always define enums or constants
- Create **enum for every set of fixed string values**
- Example: `DbStatus`, `TransitionName`, `ProductType`, `RouteNames`, `AlbumType`
- Import types directly from feature-specific files, NOT from index.ts

### 2. Type File Organization
```
src/types/
├── models.ts       # Data models (Group, Album, Lightstick)
├── collection.ts   # Collection-related types (CollectionItem, ProductType enum)
├── db.ts          # Database types (DbStatus enum)
├── routes.ts      # Router types (RouteName enum)
└── transitions.ts # Animation types (TransitionName enum)
```
- **One feature/domain = one file**
- Import directly: `import { DbStatus } from '@/types/db'`
- NOT from index.ts barrel export

### 3. Vue 3 Composition API Patterns

#### State Management
```typescript
// ✅ DO - use shallowRef for primitives
const status = shallowRef<DbStatus>(DbStatus.Idle)
const count = shallowRef(0)

// ❌ DON'T - use ref for primitives
const status = ref('idle')

// ✅ DO - use computed for derived values
const isReady = computed(() => status.value === DbStatus.Ready)

// ❌ DON'T - use watch + ref combo
watch(status, (newStatus) => { isReady.value = ... })
```

#### Async Operations
```typescript
// Use try-catch with shallowRef for error tracking
async function sync() {
  try {
    // operation
  } catch (e) {
    const errorMsg = e instanceof Error ? e.message : String(e)
    error.value = errorMsg
  }
}
```

### 4. Console Logging
- **Always use structured logging with [Module] prefix**
- Format: `console.log('[ModuleName] Action description')`
- Examples:
  ```typescript
  console.log('[useDb] Initializing database...')
  console.error('[useDataset] Sync failed:', errorMsg)
  console.log('[Router] Navigating from / to /home')
  ```

### 5. Commit Messages
- **Keep commits SHORT and descriptive**
- Format: `type: brief description (one line only)`
- Types: `feat`, `fix`, `refactor`, `style`, `docs`
- Examples:
  - ✅ `feat: add dock transition on startup`
  - ✅ `fix: remove scrollbar flicker`
  - ✅ `refactor: organize types into feature files`
  - ❌ `Add feature with detailed bullet points`

### 6. Enum Usage Requirements
Replace ALL hard-coded strings with enums:
- ✅ Database status: `DbStatus.Idle`, `DbStatus.Ready`, `DbStatus.Error`
- ✅ Transitions: `TransitionName.Startup`, `TransitionName.Page`, `TransitionName.Dock`
- ✅ Routes: `RouteName.Home`, `RouteName.Collection`
- ✅ Product types: `ProductType.Album`, `ProductType.Lightstick`
- ✅ Album types: `AlbumType.EP`, `AlbumType.Album`, `AlbumType.Single`

### 7. Import Strategy & Type Keywords
```typescript
// ✅ DO - for type-only imports, place 'type' outside braces
import type { CollectionItem, Album } from '@/types/collection'
import type { Group } from '@/types/models'

// ✅ DO - for enums used as VALUES (enum values referenced in code)
import { DbStatus } from '@/types/db'       // Used as DbStatus.Idle, DbStatus.Ready
import { RouteName } from '@/types/routes'  // Used as RouteName.Home, RouteName.Collection

// ✅ DO - for enums used ONLY as TYPES (type annotation only, never as values)
import type { ProductType } from '@/types/collection'  // Only used: productType: ProductType

// ✅ DO - for mixed imports (types + values)
import { type RouteRecordRaw, createRouter } from 'vue-router'

// ❌ DON'T - place type keyword inside braces for type-only imports
import { type CollectionItem } from '@/types/collection'

// ❌ DON'T - import from index.ts
import { DbStatus, ProductType } from '@/types'
```

**Type Keyword Rules:**
- **Type-only imports** (classes, types, interfaces): `import type { X } from ...` (keyword outside braces)
- **Enums used as VALUES** (enum values referenced): `import { DbStatus } from ...` (NO type keyword)
  - Example: `status.value = DbStatus.Idle`
- **Enums used ONLY as TYPES** (type annotation only): `import type { ProductType } from ...` (type keyword)
  - Example: `function add(id: string, type: ProductType) { ... }`
- **Mixed imports**: `import { type X, Y } from ...` (type keyword inside braces for specific types)
- **Rule of thumb:** If you use the import's value at runtime → NO `type` keyword. If it's only for type annotation → USE `type` keyword.

### 8. Router Configuration
- Keep route **paths visible** in [src/router/index.ts](src/router/index.ts)
- Use **RouteName enum for route names only**
- Example:
  ```typescript
  { path: '/home', name: RouteName.Home, component: Home }
  ```

### 9. Transition Animations
- Page transitions: `TransitionName.Page` (fade, 400ms)
- Startup transition: `TransitionName.Startup` (slide+fade, 600ms)
- Dock transition: `TransitionName.Dock` (slide+fade, 500ms)
- **Always use mode="out-in"** to prevent visual overlap

### 10. Component Conventions
- Use `<script setup>` syntax
- Compose functionality via `use*` composables
- Error handling: Show toast notifications for user-facing errors
- Computed properties for route-based logic
- Add CSS `overflow: hidden` to prevent scrollbar flicker during animations

## Project Structure
```
kolect/
├── src/
│   ├── types/           # Type definitions (by feature)
│   ├── composables/     # Vue composables (use-*)
│   ├── screens/         # Page components
│   ├── components/      # Reusable components
│   ├── router/          # Route configuration
│   ├── styles/          # SCSS files
│   ├── locales/         # i18n messages
│   └── App.vue          # Root component
├── src-tauri/           # Tauri backend
│   └── src/
│       ├── db.rs        # Database operations
│       ├── commands/    # Tauri command handlers
│       └── main.rs
└── package.json         # Frontend dependencies
```

## Common Workflows

### Adding a New Feature Type
1. Create enum in appropriate `src/types/*.ts` file
2. Use enum values instead of strings in code
3. Import directly from feature file
4. Example: Added `AlbumType` enum in `types/models.ts`

### Fixing Magic Strings
1. Identify all hard-coded string values
2. Create enum in appropriate types file
3. Replace all usages
4. Update imports in dependent files
5. Build and test

### Creating New Routes
1. Define route in [src/router/index.ts](src/router/index.ts) with visible path
2. Add to `RouteName` enum in [src/types/routes.ts](src/types/routes.ts)
3. Use `RouteName.X` for route names in config

## Build & Development
```bash
bun run dev:front       # Start frontend dev server
bun run build:front     # Build frontend
bun run tauri dev       # Run Tauri app in dev mode
```

## Standards Established
- ✅ All status/enum values typed
- ✅ Feature-specific type files
- ✅ No index.ts barrel exports (import directly)
- ✅ Short, semantic commit messages
- ✅ Structured console logging
- ✅ shallowRef for primitives
- ✅ computed for derived values
- ✅ Transitions with mode="out-in"
- ✅ ProductType enum for collection items
- ✅ AlbumType enum for album types
- ✅ DbStatus enum for database state

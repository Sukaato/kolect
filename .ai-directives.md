# AI Development Directives for Kolect

## Project Overview
- **Type**: Vue 3 + Tauri mobile app for K-pop collection tracking
- **Frontend**: Vue 3.5 (Composition API), TypeScript, DaisyUI, Tailwind CSS
- **Backend**: Rust with Tauri, SQLite database
- **Build Tool**: Bun
- **I18n**: EN/FR localization via vue-i18n

## Core Principles

### 1. Type Safety
- **NEVER** use magic strings - always define enums or constants
- Create **enum for every set of fixed string values**
- Example: `DbStatus`, `TransitionName`, `ProductType`, `RouteNames`, `AlbumType`
- Import types directly from feature-specific files, NOT from index.ts

### 2. Type File Organization
```
src/types/
├── models.ts       # Data models (Group, Album, Lightstick)
├── collection.ts   # Collection-related types (CollectionItem, ProductType enum)
├── db.ts          # Database types (DbStatus enum)
├── routes.ts      # Router types (RouteName enum)
└── transitions.ts # Animation types (TransitionName enum)
```
- **One feature/domain = one file**
- Import directly: `import { DbStatus } from '@/types/db'`
- NOT from index.ts barrel export

### 3. Vue 3 Composition API Patterns

#### State Management
```typescript
// ✅ DO - use shallowRef for primitives
const status = shallowRef<DbStatus>(DbStatus.Idle)
const count = shallowRef(0)

// ❌ DON'T - use ref for primitives
const status = ref('idle')

// ✅ DO - use computed for derived values
const isReady = computed(() => status.value === DbStatus.Ready)

// ❌ DON'T - use watch + ref combo
watch(status, (newStatus) => { isReady.value = ... })
```

#### Async Operations
```typescript
// Use try-catch with shallowRef for error tracking
async function sync() {
  try {
    // operation
  } catch (e) {
    const errorMsg = e instanceof Error ? e.message : String(e)
    error.value = errorMsg
  }
}
```

### 4. Logging
- **Use `useLogger()` composable instead of `console.log`**
- The composable invokes a Tauri `log` command with level, message, and optional body
- Fallback to console if Tauri is unavailable
- Format: Messages use `[Module]` prefix for clarity
- Examples:
  ```typescript
  const { info, debug, warn, error } = useLogger()
  info('[useDb] Database initialized successfully')
  error('[Startup] Initialization failed:', errorMsg)
  debug('[Router] Navigation completed', { from, to })
  ```
- Logs include timestamps and are captured server-side
- Supports JSON bodies for structured logging

### 5. Commit Messages
- **ALWAYS keep commits SHORT - maximum one line**
- Format: `type: description` (3-6 words max in description)
- Types: `feat`, `fix`, `refactor`, `style`, `docs`, `chore`
- Examples:
  - ✅ `feat: add dock transition`
  - ✅ `fix: remove scrollbar flicker`
  - ✅ `refactor: update enum keys`
  - ❌ `feat: add new feature with detailed description explaining all changes`
  - ❌ Multiple lines or bullet points
- **NO timestamps, no "WIP", no brackets, no emojis**

### 6. Enum Usage Requirements
Replace ALL hard-coded strings with enums:
- ✅ Database status: `DbStatus.Idle`, `DbStatus.Ready`, `DbStatus.Error`
- ✅ Transitions: `TransitionName.Startup`, `TransitionName.Page`, `TransitionName.Dock`
- ✅ Routes: `RouteName.Home`, `RouteName.Collection`
- ✅ Product types: `ProductType.Album`, `ProductType.Lightstick`
- ✅ Album types: `AlbumType.EP`, `AlbumType.Album`, `AlbumType.Single`

### 7. Import Strategy & Type Keywords
```typescript
// ✅ DO - for type-only imports, place 'type' outside braces
import type { CollectionItem, Album } from '@/types/collection'
import type { Group } from '@/types/models'

// ✅ DO - for enums used as VALUES (enum values referenced in code)
import { DbStatus } from '@/types/db'       // Used as DbStatus.Idle, DbStatus.Ready
import { RouteName } from '@/types/routes'  // Used as RouteName.Home, RouteName.Collection

// ✅ DO - for enums used ONLY as TYPES (type annotation only, never as values)
import type { ProductType } from '@/types/collection'  // Only used: productType: ProductType

// ✅ DO - for mixed imports (types + values)
import { type RouteRecordRaw, createRouter } from 'vue-router'

// ❌ DON'T - place type keyword inside braces for type-only imports
import { type CollectionItem } from '@/types/collection'

// ❌ DON'T - import from index.ts
import { DbStatus, ProductType } from '@/types'
```

**Type Keyword Rules:**
- **Type-only imports** (classes, types, interfaces): `import type { X } from ...` (keyword outside braces)
- **Enums used as VALUES** (enum values referenced): `import { DbStatus } from ...` (NO type keyword)
  - Example: `status.value = DbStatus.Idle`
- **Enums used ONLY as TYPES** (type annotation only): `import type { ProductType } from ...` (type keyword)
  - Example: `function add(id: string, type: ProductType) { ... }`
- **Mixed imports**: `import { type X, Y } from ...` (type keyword inside braces for specific types)
- **Rule of thumb:** If you use the import's value at runtime → NO `type` keyword. If it's only for type annotation → USE `type` keyword.

### 8. Router Configuration
- Keep route **paths visible** in [src/router/index.ts](src/router/index.ts)
- Use **RouteName enum for route names only**
- Example:
  ```typescript
  { path: '/home', name: RouteName.Home, component: Home }
  ```

### 9. Transition Animations
- Page transitions: `TransitionName.Page` (fade, 400ms)
- Startup transition: `TransitionName.Startup` (slide+fade, 600ms)
- Dock transition: `TransitionName.Dock` (slide+fade, 500ms)
- **Always use mode="out-in"** to prevent visual overlap

### 10. Component Conventions
- Use `<script setup>` syntax
- Compose functionality via `use*` composables
- Error handling: Show toast notifications for user-facing errors
- Computed properties for route-based logic
- Add CSS `overflow: hidden` to prevent scrollbar flicker during animations

## Project Structure
```
kolect/
├── src/
│   ├── types/           # Type definitions (by feature)
│   ├── composables/     # Vue composables (use-*)
│   ├── screens/         # Page components
│   ├── components/      # Reusable components
│   ├── router/          # Route configuration
│   ├── styles/          # SCSS files
│   ├── locales/         # i18n messages
│   └── App.vue          # Root component
├── src-tauri/           # Tauri backend
│   └── src/
│       ├── db.rs        # Database operations
│       ├── commands/    # Tauri command handlers
│       └── main.rs
└── package.json         # Frontend dependencies
```

## Common Workflows

### Adding a New Feature Type
1. Create enum in appropriate `src/types/*.ts` file
2. Use enum values instead of strings in code
3. Import directly from feature file
4. Example: Added `AlbumType` enum in `types/models.ts`

### Fixing Magic Strings
1. Identify all hard-coded string values
2. Create enum in appropriate types file
3. Replace all usages
4. Update imports in dependent files
5. Build and test

### Creating New Routes
1. Define route in [src/router/index.ts](src/router/index.ts) with visible path
2. Add to `RouteName` enum in [src/types/routes.ts](src/types/routes.ts)
3. Use `RouteName.X` for route names in config

## Build & Development
```bash
bun run dev:front       # Start frontend dev server
bun run build:front     # Build frontend
bun run tauri dev       # Run Tauri app in dev mode
bun biome format --write .  # Format code
bun biome check --fix .     # Lint and fix
```

## Logging System Implementation

### Frontend (Vue)
- **useLogger composable** at [src/composables/shared/use-logger.ts](src/composables/shared/use-logger.ts)
- Methods: `debug()`, `info()`, `warn()`, `error()`
- Each accepts: message string + optional body (string or JSON)
- Calls Tauri `log` command asynchronously
- Fallback to console.log if Tauri unavailable

### Backend (Rust)
- **log command** in [src-tauri/src/commands/mod.rs](src-tauri/src/commands/mod.rs)
- Parameters: `level`, `message`, `body` (optional)
- Outputs with timestamp: `[YYYY-MM-DD HH:MM:SS.sss] [LEVEL] message | body`
- Error/warn use stderr, debug/info use stdout
- Useful for debugging app behavior during development

## Standards Established
- ✅ All status/enum values typed
- ✅ Feature-specific type files
- ✅ No index.ts barrel exports (import directly)
- ✅ Short, semantic commit messages (3-6 words max)
- ✅ Structured logging via `useLogger()` composable
- ✅ Enum keys in UPPERCASE_SNAKE_CASE (except where values differ)
- ✅ DbStatus as union type (not enum) for better type safety
- ✅ shallowRef for primitives
- ✅ computed for derived values
- ✅ Transitions with mode="out-in"
- ✅ ProductType enum for collection items
- ✅ AlbumType enum for album types
